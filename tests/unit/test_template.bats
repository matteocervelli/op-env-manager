#!/usr/bin/env bats
# Unit tests for lib/template.sh
# Tests template generation functions

load ../test_helper/common

# =============================================================================
# Test Setup and Teardown
# =============================================================================

setup() {
    verify_test_environment
    setup_temp_dir
    source "$LIB_DIR/template.sh"
}

teardown() {
    teardown_temp_dir
}

# =============================================================================
# Test: Module Exists
# =============================================================================

@test "template.sh exists and is readable" {
    assert_file_exists "$LIB_DIR/template.sh"
    assert [ -r "$LIB_DIR/template.sh" ]
}

# =============================================================================
# Test: generate_op_reference Function
# =============================================================================

@test "generate_op_reference creates reference without section" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_op_reference 'Personal' 'myapp' '' 'API_KEY'
    "
    assert_success
    assert_output "API_KEY=op://Personal/myapp/API_KEY"
}

@test "generate_op_reference creates reference with section using \$APP_ENV" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_op_reference 'Personal' 'myapp' 'production' 'API_KEY'
    "
    assert_success
    assert_output "API_KEY=op://Personal/myapp/\$APP_ENV/API_KEY"
}

@test "generate_op_reference uses correct vault name" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_op_reference 'Projects' 'app' '' 'SECRET'
    "
    assert_success
    assert_output "SECRET=op://Projects/app/SECRET"
}

@test "generate_op_reference uses correct item name" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_op_reference 'Personal' 'myapp-prod' '' 'DATABASE_URL'
    "
    assert_success
    assert_output "DATABASE_URL=op://Personal/myapp-prod/DATABASE_URL"
}

@test "generate_op_reference handles multiple calls" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_op_reference 'Personal' 'myapp' '' 'API_KEY'
        generate_op_reference 'Personal' 'myapp' '' 'DATABASE_URL'
        generate_op_reference 'Personal' 'myapp' '' 'SECRET'
    "
    assert_success
    assert_line --index 0 "API_KEY=op://Personal/myapp/API_KEY"
    assert_line --index 1 "DATABASE_URL=op://Personal/myapp/DATABASE_URL"
    assert_line --index 2 "SECRET=op://Personal/myapp/SECRET"
}

# =============================================================================
# Test: generate_template_file Function
# =============================================================================

@test "generate_template_file creates file with header" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'API_KEY' 'DATABASE_URL'
    "
    assert_success
    assert_file_exists "$output"
    
    # Check header content
    grep -q "Generated by op-env-manager" "$output"
    grep -q "Vault: Personal" "$output"
    grep -q "Item: myapp" "$output"
}

@test "generate_template_file includes vault information" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Projects' 'myapp' '' '$output' 'KEY'
    "
    assert_success
    grep -q "Vault: Projects" "$output"
}

@test "generate_template_file includes item information" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'KEY'
    "
    assert_success
    grep -q "Item: myapp" "$output"
}

@test "generate_template_file includes section in header when specified" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' 'production' '$output' 'KEY'
    "
    assert_success
    grep -q "Section: \\\$APP_ENV" "$output"
    grep -q "production" "$output"
}

@test "generate_template_file includes section none when not specified" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'KEY'
    "
    assert_success
    grep -q "Section: none" "$output"
}

@test "generate_template_file includes timestamp" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'KEY'
    "
    assert_success
    grep -q "Generated: 20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]" "$output"
}

@test "generate_template_file creates op:// references for all fields" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    run bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'API_KEY' 'DATABASE_URL' 'SECRET'
    "
    assert_success
    grep -q "API_KEY=op://" "$output"
    grep -q "DATABASE_URL=op://" "$output"
    grep -q "SECRET=op://" "$output"
}

@test "generate_template_file sets file permissions to 600" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'KEY'
    "
    
    # Check permissions are 600 (owner read/write only)
    local perms
    perms=$(stat -f "%OLp" "$output" 2>/dev/null || stat -c "%a" "$output")
    [[ "$perms" == "600" ]]
}

# =============================================================================
# Test: Argument Parsing for standalone command
# =============================================================================

@test "parse_args sets VAULT from --vault=VALUE" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        parse_args --vault='Personal' --item='myapp'
        echo \$VAULT
    "
    assert_success
    assert_output "Personal"
}

@test "parse_args sets ITEM_NAME from --item=VALUE" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        parse_args --vault='Personal' --item='myapp'
        echo \$ITEM_NAME
    "
    assert_success
    assert_output "myapp"
}

@test "parse_args sets SECTION from --section=VALUE" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        parse_args --vault='Personal' --section='staging'
        echo \$SECTION
    "
    assert_success
    assert_output "staging"
}

@test "parse_args sets OUTPUT_FILE from --output=VALUE" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        parse_args --vault='Personal' --output='.env.custom'
        echo \$OUTPUT_FILE
    "
    assert_success
    assert_output ".env.custom"
}

@test "parse_args sets DRY_RUN from --dry-run" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        parse_args --vault='Personal' --dry-run
        [[ \$DRY_RUN == 'true' ]] && echo 'true' || echo 'false'
    "
    assert_success
    assert_output "true"
}

# =============================================================================
# Test: Default Values
# =============================================================================

@test "ITEM_NAME defaults to env-secrets" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        echo \$ITEM_NAME
    "
    assert_output "env-secrets"
}

@test "OUTPUT_FILE defaults to .env.op" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        echo \$OUTPUT_FILE
    "
    assert_output ".env.op"
}

@test "SECTION defaults to empty string" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        [[ -z \$SECTION ]] && echo 'empty' || echo 'not empty'
    "
    assert_output "empty"
}

@test "DRY_RUN defaults to false" {
    run bash -c "
        source '$LIB_DIR/template.sh'
        [[ \$DRY_RUN == 'false' ]] && echo 'true' || echo 'false'
    "
    assert_output "true"
}

# =============================================================================
# Test: Template File Format
# =============================================================================

@test "template file has correct line format for fields" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'API_KEY'
    "
    
    # Last line should be the API_KEY reference
    local last_line
    last_line=$(tail -1 "$output")
    [[ "$last_line" =~ ^API_KEY=op:// ]]
}

@test "template file with section uses \$APP_ENV variable" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' 'prod' '$output' 'API_KEY'
    "
    
    grep -q '\$APP_ENV' "$output"
}

# =============================================================================
# Test: Integration Scenarios
# =============================================================================

@test "generate_template_file with multiple fields from fixture" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' \
            'API_KEY' 'DATABASE_URL' 'SECRET' 'DEBUG'
    "
    
    # Count op:// references
    local count
    count=$(grep -c 'op://' "$output" || true)
    [ "$count" -eq 4 ]
}

@test "template files can be sourced as shell env files" {
    local output
    output="$TEST_TEMP_DIR/test.env.op"
    
    bash -c "
        source '$LIB_DIR/template.sh'
        generate_template_file 'Personal' 'myapp' '' '$output' 'API_KEY'
    "
    
    # Should be able to source the file
    bash -c "source '$output' && echo 'sourced'"
}

