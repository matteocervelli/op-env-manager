#!/usr/bin/env bash
# Template generation utilities for op-env-manager
# Part of op-env-manager by Matteo Cervelli

set -eo pipefail

# Get script directory
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/error_helpers.sh"
source "$LIB_DIR/retry.sh"

# Global variables for standalone command
VAULT=""
ITEM_NAME="env-secrets"
SECTION=""
OUTPUT_FILE=".env.op"
ENV_FILE=""
DRY_RUN=false

# Generate op:// reference string for a single field
# Usage: generate_op_reference "vault" "item" "section" "field_name"
# Returns: field_name=op://vault/item/$APP_ENV/field_name (if section)
#          field_name=op://vault/item/field_name (if no section)
generate_op_reference() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local field_name="$4"

    if [ -n "$section" ]; then
        # Use $APP_ENV variable for dynamic section switching
        echo "${field_name}=op://${vault}/${item}/\$APP_ENV/${field_name}"
    else
        # No section - direct field reference
        echo "${field_name}=op://${vault}/${item}/${field_name}"
    fi
}

# Parse .env file preserving structure (comments, blank lines, order)
# Usage: parse_env_with_structure "file_path"
# Returns: Array of lines (comments, blanks, KEY=value entries)
parse_env_with_structure() {
    local file_path="$1"

    if [ ! -f "$file_path" ]; then
        log_error "File not found: $file_path"
        return 1
    fi

    # Read file line by line, preserve everything
    while IFS= read -r line || [ -n "$line" ]; do
        echo "$line"
    done < "$file_path"
}

# Check if a field exists in 1Password item/section
# Usage: check_field_exists "vault" "item" "section" "field_name" "item_json"
# Returns: 0 if exists, 1 if not
check_field_exists() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local field_name="$4"
    local item_json="$5"

    local found
    if [ -n "$section" ]; then
        # Check in specific section
        found=$(echo "$item_json" | jq -r ".fields[] | select(.section.label == \"$section\" and .label == \"$field_name\") | .label")
    else
        # Check without section
        found=$(echo "$item_json" | jq -r ".fields[] | select(.section == null and .label == \"$field_name\") | .label")
    fi

    [ -n "$found" ]
}

# Merge template file (.env.example) with 1Password references
# Usage: merge_template_with_1password "vault" "item" "section" "env_file" "output_path" "item_json"
# Creates hybrid file:
#   - Preserves .env.example structure/comments
#   - Replaces values with op:// references where available in 1Password
#   - Keeps original values for missing vars (with warning comment)
#   - Appends extra 1Password vars at end
merge_template_with_1password() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local env_file="$4"
    local output_path="$5"
    local item_json="$6"

    local temp_output
    temp_output=$(mktemp)
    local temp_processed
    temp_processed=$(mktemp)
    trap 'rm -f "$temp_output" "$temp_processed"' RETURN

    # Track which 1Password fields we've processed (using temp file for Bash 3 compatibility)
    local missing_count=0

    # Generate header
    cat > "$temp_output" << EOF
# Generated by op-env-manager from: $(basename "$env_file")
# Vault: ${vault}
# Item: ${item}
EOF

    if [ -n "$section" ]; then
        echo "# Section: \$APP_ENV (dynamic - set to: ${section})" >> "$temp_output"
    else
        echo "# Section: none" >> "$temp_output"
    fi

    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$temp_output"
    echo "" >> "$temp_output"

    # Process .env.example line by line
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve comments and blank lines
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            echo "$line" >> "$temp_output"
            continue
        fi

        # Parse KEY=value lines
        if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)= ]]; then
            local var_name="${BASH_REMATCH[1]}"

            # Check if this field exists in 1Password
            if check_field_exists "$vault" "$item" "$section" "$var_name" "$item_json"; then
                # Replace with op:// reference
                generate_op_reference "$vault" "$item" "$section" "$var_name" >> "$temp_output"
                echo "$var_name" >> "$temp_processed"
            else
                # Keep original line but add warning comment
                echo "# WARNING: '$var_name' not found in 1Password - push this variable first" >> "$temp_output"
                echo "$line" >> "$temp_output"
                missing_count=$((missing_count + 1))
            fi
        else
            # Preserve any other lines as-is
            echo "$line" >> "$temp_output"
        fi
    done < "$env_file"

    # Find fields in 1Password that weren't in .env.example
    local extra_fields_found=0
    if [ -n "$section" ]; then
        while IFS= read -r field_name; do
            if [ -n "$field_name" ] && ! grep -qxF "$field_name" "$temp_processed" 2>/dev/null; then
                if [ "$extra_fields_found" -eq 0 ]; then
                    echo "" >> "$temp_output"
                    echo "# Additional variables from 1Password (not in original template)" >> "$temp_output"
                    extra_fields_found=1
                fi
                generate_op_reference "$vault" "$item" "$section" "$field_name" >> "$temp_output"
            fi
        done < <(echo "$item_json" | jq -r ".fields[] | select(.section.label == \"$section\") | .label")
    else
        while IFS= read -r field_name; do
            if [ -n "$field_name" ] && ! grep -qxF "$field_name" "$temp_processed" 2>/dev/null; then
                if [ "$extra_fields_found" -eq 0 ]; then
                    echo "" >> "$temp_output"
                    echo "# Additional variables from 1Password (not in original template)" >> "$temp_output"
                    extra_fields_found=1
                fi
                generate_op_reference "$vault" "$item" "$section" "$field_name" >> "$temp_output"
            fi
        done < <(echo "$item_json" | jq -r '.fields[] | select(.section == null) | .label')
    fi

    # Move to final output
    mv "$temp_output" "$output_path"
    chmod 600 "$output_path"

    # Return count of missing vars for warning
    echo "$missing_count"
}

# Generate template file with op:// references
# Usage: generate_template_file "vault" "item" "section" "output_path" "field_names_array"
# Creates .env.op file with header and op:// references
generate_template_file() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local output_path="$4"
    shift 4
    local field_names=("$@")

    # Generate header
    cat > "$output_path" << EOF
# Generated by op-env-manager
# Vault: ${vault}
# Item: ${item}
EOF

    if [ -n "$section" ]; then
        echo "# Section: \$APP_ENV (dynamic - set to: ${section})" >> "$output_path"
    else
        echo "# Section: none" >> "$output_path"
    fi

    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$output_path"
    echo "" >> "$output_path"

    # Generate op:// references
    for field_name in "${field_names[@]}"; do
        generate_op_reference "$vault" "$item" "$section" "$field_name" >> "$output_path"
    done

    # Set secure permissions
    chmod 600 "$output_path"
}

# Get field names from 1Password item
# Usage: get_field_names_from_item "vault" "item" "section"
# Returns: Array of field names
get_field_names_from_item() {
    local vault="$1"
    local item="$2"
    local section="$3"

    # Get item JSON
    local item_json
    local error_output
    error_output=$(mktemp)
    trap 'rm -f "$error_output"' EXIT

    item_json=$(retry_with_backoff "get item from vault" op item get "$item" --vault "$vault" --format json 2>"$error_output")

    if [ -z "$item_json" ]; then
        local error_msg
        error_msg=$(cat "$error_output")

        log_error "Item not found: $item in vault $vault"

        # Check for specific errors
        if echo "$error_msg" | grep -qi "vault.*not found"; then
            suggest_vault_list "$vault"
        else
            suggest_item_push "$vault" "$item"
            suggest_item_list "$vault" "$item"
        fi
        return 1
    fi

    # Extract field names based on section
    local field_names=()
    if [ -n "$section" ]; then
        # Get fields from specific section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r ".fields[] | select(.section.label == \"$section\") | .label")
    else
        # Get fields without section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r '.fields[] | select(.section == null) | .label')
    fi

    # Return field names (one per line)
    printf '%s\n' "${field_names[@]}"
}

# Standalone template command
template_command() {
    log_header "Generating op:// Template File"
    echo ""

    if [ -z "$VAULT" ]; then
        log_error "--vault is required"
        echo "" >&2
        log_suggestion "Specify a vault name:"
        log_command "op-env-manager template --vault=\"VaultName\" --item=\"item-name\""
        echo "" >&2
        suggest_vault_list
        usage
    fi

    if [ "$DRY_RUN" = false ]; then
        # Use centralized diagnostics from error_helpers
        if ! diagnose_op_cli; then
            exit 1
        fi
    fi

    log_info "Vault: $VAULT"
    log_info "Item: $ITEM_NAME"
    if [ -n "$SECTION" ]; then
        log_info "Section: $SECTION (will use \$APP_ENV variable)"
    fi
    if [ -n "$ENV_FILE" ]; then
        log_info "Template: $ENV_FILE"
    fi
    log_info "Output: $OUTPUT_FILE"
    echo ""

    if [ "$DRY_RUN" = true ]; then
        log_warning "DRY RUN: Would generate template file"
        log_info "Remove --dry-run to generate for real"
        exit 0
    fi

    # Choose generation mode based on --env-file flag
    if [ -n "$ENV_FILE" ]; then
        # Mode 1: Merge with existing .env file (preserve structure)
        log_info "Mode: Merge with template file"
        echo ""

        # Validate env file exists
        if [ ! -f "$ENV_FILE" ]; then
            log_error "Template file not found: $ENV_FILE"
            suggest_file_check "$ENV_FILE"
            exit 1
        fi

        # Get 1Password item JSON (needed to check field existence)
        log_step "Fetching fields from 1Password..."
        local item_json
        local error_output
        error_output=$(mktemp)
        trap 'rm -f "$error_output"' EXIT

        item_json=$(retry_with_backoff "get item from vault" op item get "$ITEM_NAME" --vault "$VAULT" --format json 2>"$error_output")

        if [ -z "$item_json" ]; then
            local error_msg
            error_msg=$(cat "$error_output")

            log_error "Item not found: $ITEM_NAME in vault $VAULT"

            # Check for specific errors
            if echo "$error_msg" | grep -qi "vault.*not found"; then
                suggest_vault_list "$VAULT"
            else
                suggest_item_push "$VAULT" "$ITEM_NAME"
                suggest_item_list "$VAULT" "$ITEM_NAME"
            fi
            exit 1
        fi

        log_success "Item found"
        echo ""

        # Generate merged template
        log_step "Merging template with 1Password references..."
        local missing_count
        missing_count=$(merge_template_with_1password "$VAULT" "$ITEM_NAME" "$SECTION" "$ENV_FILE" "$OUTPUT_FILE" "$item_json")

        log_success "Template file created: $OUTPUT_FILE"

        # Warn about missing variables
        if [ "$missing_count" -gt 0 ]; then
            echo ""
            log_warning "$missing_count variable(s) not found in 1Password"
            log_suggestion "Push missing variables first:"
            log_command "op-env-manager push --vault=\"$VAULT\" --item=\"$ITEM_NAME\" --env-file=\"$ENV_FILE\""
        fi

    else
        # Mode 2: Generate from scratch from 1Password (original behavior)
        log_info "Mode: Generate from 1Password"
        echo ""

        # Get field names from 1Password
        log_step "Fetching field names from 1Password..."
        local field_names
        field_names=$(get_field_names_from_item "$VAULT" "$ITEM_NAME" "$SECTION")

        if [ -z "$field_names" ]; then
            if [ -n "$SECTION" ]; then
                log_error "No fields found in section: $SECTION"
                suggest_section_check "$VAULT" "$ITEM_NAME" "$SECTION"

                echo "" >&2
                log_suggestion "Or push your environment to this section:"
                log_command "op-env-manager push --vault=\"$VAULT\" --item=\"$ITEM_NAME\" --section=\"$SECTION\" --env-file=\".env\""
            else
                log_error "No fields found in item: $ITEM_NAME"
                echo "" >&2
                suggest_item_push "$VAULT" "$ITEM_NAME"
            fi
            exit 1
        fi

        # Convert field names to array
        local field_array=()
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_array+=("$field_name")
        done <<< "$field_names"

        local field_count=${#field_array[@]}
        log_success "Found $field_count fields"
        echo ""

        # Generate template file
        log_step "Generating template file..."
        generate_template_file "$VAULT" "$ITEM_NAME" "$SECTION" "$OUTPUT_FILE" "${field_array[@]}"

        log_success "Template file created: $OUTPUT_FILE"
    fi
    echo ""
    log_info "Preview:"
    head -n 15 "$OUTPUT_FILE"
    local total_lines
    total_lines=$(wc -l < "$OUTPUT_FILE")
    if [ "$total_lines" -gt 15 ]; then
        echo "... (showing first 15 lines)"
    fi
    echo ""
    log_info "Usage:"
    echo "  # Check into version control (safe - no plaintext secrets)"
    echo "  git add $OUTPUT_FILE"
    echo ""
    echo "  # Use with op run for runtime injection"
    if [ -n "$SECTION" ]; then
        echo "  export APP_ENV=\"$SECTION\""
    fi
    echo "  op run --env-file=$OUTPUT_FILE -- your-command"
}

# Show usage for standalone command
usage() {
    cat << EOF
Usage: op-env-manager template [options]

Generate .env.op template file with op:// secret references. Supports two modes:
1. Generate from 1Password (default) - creates new file from existing item
2. Merge with template (--env-file) - preserves structure/comments from existing file

The generated file can be safely checked into version control and used with
'op run' for runtime secret injection.

Options:
    --vault=VAULT       1Password vault name (required)
    --item=NAME         Item name (default: env-secrets)
    --section=SECTION   Environment section (e.g., dev, prod, staging)
    --env-file=FILE     Template file to merge with (e.g., .env.example)
    --output=FILE       Output file path (default: .env.op)
    --dry-run           Preview without generating file

Examples:
    # Mode 1: Generate from 1Password (original behavior)
    op-env-manager template --vault="Personal" --item="myapp"

    # Mode 2: Merge .env.example with 1Password references
    op-env-manager template --vault="Personal" --item="myapp" --env-file=".env.example"

    # With section (uses \$APP_ENV variable for dynamic switching)
    op-env-manager template --vault="Projects" --item="myapp" --section="dev" --env-file=".env.example"

    # Custom output filename
    op-env-manager template --vault="Personal" --output=".env.template"

Merge Mode Behavior (--env-file):
    - Preserves all comments and structure from source file
    - Variables in 1Password → replaced with op:// references
    - Variables NOT in 1Password → kept as-is with warning comment
    - Extra 1Password variables → appended at end

Generated Format:
    # With section:
    API_KEY=op://Personal/myapp/\$APP_ENV/API_KEY

    # Without section:
    API_KEY=op://Personal/myapp/API_KEY

Usage with op run:
    # Set APP_ENV to select section dynamically
    export APP_ENV="dev"
    op run --env-file=.env.op -- docker compose up

EOF
    exit 1
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vault=*)
                VAULT="${1#*=}"
                shift
                ;;
            --vault)
                VAULT="$2"
                shift 2
                ;;
            --item=*)
                ITEM_NAME="${1#*=}"
                shift
                ;;
            --item)
                ITEM_NAME="$2"
                shift 2
                ;;
            --section=*)
                SECTION="${1#*=}"
                shift
                ;;
            --section)
                SECTION="$2"
                shift 2
                ;;
            --output=*)
                OUTPUT_FILE="${1#*=}"
                shift
                ;;
            --output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --env-file=*)
                ENV_FILE="${1#*=}"
                shift
                ;;
            --env-file)
                ENV_FILE="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done
}

# Main function for standalone execution
main() {
    parse_args "$@"
    template_command
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
