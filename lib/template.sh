#!/usr/bin/env bash
# Template generation utilities for op-env-manager
# Part of op-env-manager by Matteo Cervelli

set -eo pipefail

# Get script directory
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/error_helpers.sh"

# Global variables for standalone command
VAULT=""
ITEM_NAME="env-secrets"
SECTION=""
OUTPUT_FILE=".env.op"
DRY_RUN=false

# Generate op:// reference string for a single field
# Usage: generate_op_reference "vault" "item" "section" "field_name"
# Returns: field_name=op://vault/item/$APP_ENV/field_name (if section)
#          field_name=op://vault/item/field_name (if no section)
generate_op_reference() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local field_name="$4"

    if [ -n "$section" ]; then
        # Use $APP_ENV variable for dynamic section switching
        echo "${field_name}=op://${vault}/${item}/\$APP_ENV/${field_name}"
    else
        # No section - direct field reference
        echo "${field_name}=op://${vault}/${item}/${field_name}"
    fi
}

# Generate template file with op:// references
# Usage: generate_template_file "vault" "item" "section" "output_path" "field_names_array"
# Creates .env.op file with header and op:// references
generate_template_file() {
    local vault="$1"
    local item="$2"
    local section="$3"
    local output_path="$4"
    shift 4
    local field_names=("$@")

    # Generate header
    cat > "$output_path" << EOF
# Generated by op-env-manager
# Vault: ${vault}
# Item: ${item}
EOF

    if [ -n "$section" ]; then
        echo "# Section: \$APP_ENV (dynamic - set to: ${section})" >> "$output_path"
    else
        echo "# Section: none" >> "$output_path"
    fi

    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$output_path"
    echo "" >> "$output_path"

    # Generate op:// references
    for field_name in "${field_names[@]}"; do
        generate_op_reference "$vault" "$item" "$section" "$field_name" >> "$output_path"
    done

    # Set secure permissions
    chmod 600 "$output_path"
}

# Get field names from 1Password item
# Usage: get_field_names_from_item "vault" "item" "section"
# Returns: Array of field names
get_field_names_from_item() {
    local vault="$1"
    local item="$2"
    local section="$3"

    # Get item JSON
    local item_json
    local error_output
    error_output=$(mktemp)
    trap 'rm -f "$error_output"' EXIT

    item_json=$(op item get "$item" --vault "$vault" --format json 2>"$error_output")

    if [ -z "$item_json" ]; then
        local error_msg
        error_msg=$(cat "$error_output")

        log_error "Item not found: $item in vault $vault"

        # Check for specific errors
        if echo "$error_msg" | grep -qi "vault.*not found"; then
            suggest_vault_list "$vault"
        else
            suggest_item_push "$vault" "$item"
            suggest_item_list "$vault" "$item"
        fi
        return 1
    fi

    # Extract field names based on section
    local field_names=()
    if [ -n "$section" ]; then
        # Get fields from specific section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r ".fields[] | select(.section.label == \"$section\") | .label")
    else
        # Get fields without section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r '.fields[] | select(.section == null) | .label')
    fi

    # Return field names (one per line)
    printf '%s\n' "${field_names[@]}"
}

# Standalone template command
template_command() {
    log_header "Generating op:// Template File"
    echo ""

    if [ -z "$VAULT" ]; then
        log_error "--vault is required"
        echo "" >&2
        log_suggestion "Specify a vault name:"
        log_command "op-env-manager template --vault=\"VaultName\" --item=\"item-name\""
        echo "" >&2
        suggest_vault_list
        usage
    fi

    if [ "$DRY_RUN" = false ]; then
        # Use centralized diagnostics from error_helpers
        if ! diagnose_op_cli; then
            exit 1
        fi
    fi

    log_info "Vault: $VAULT"
    log_info "Item: $ITEM_NAME"
    if [ -n "$SECTION" ]; then
        log_info "Section: $SECTION (will use \$APP_ENV variable)"
    fi
    log_info "Output: $OUTPUT_FILE"
    echo ""

    if [ "$DRY_RUN" = true ]; then
        log_warning "DRY RUN: Would generate template file"
        log_info "Remove --dry-run to generate for real"
        exit 0
    fi

    # Get field names from 1Password
    log_step "Fetching field names from 1Password..."
    local field_names
    field_names=$(get_field_names_from_item "$VAULT" "$ITEM_NAME" "$SECTION")

    if [ -z "$field_names" ]; then
        if [ -n "$SECTION" ]; then
            log_error "No fields found in section: $SECTION"
            suggest_section_check "$VAULT" "$ITEM_NAME" "$SECTION"

            echo "" >&2
            log_suggestion "Or push your environment to this section:"
            log_command "op-env-manager push --vault=\"$VAULT\" --item=\"$ITEM_NAME\" --section=\"$SECTION\" --env-file=\".env\""
        else
            log_error "No fields found in item: $ITEM_NAME"
            echo "" >&2
            suggest_item_push "$VAULT" "$ITEM_NAME"
        fi
        exit 1
    fi

    # Convert field names to array
    local field_array=()
    while IFS= read -r field_name; do
        [ -n "$field_name" ] && field_array+=("$field_name")
    done <<< "$field_names"

    local field_count=${#field_array[@]}
    log_success "Found $field_count fields"
    echo ""

    # Generate template file
    log_step "Generating template file..."
    generate_template_file "$VAULT" "$ITEM_NAME" "$SECTION" "$OUTPUT_FILE" "${field_array[@]}"

    log_success "Template file created: $OUTPUT_FILE"
    echo ""
    log_info "Preview:"
    head -n 15 "$OUTPUT_FILE"
    if [ "$field_count" -gt 10 ]; then
        echo "... (showing first 10 fields)"
    fi
    echo ""
    log_info "Usage:"
    echo "  # Check into version control (safe - no plaintext secrets)"
    echo "  git add $OUTPUT_FILE"
    echo ""
    echo "  # Use with op run for runtime injection"
    if [ -n "$SECTION" ]; then
        echo "  export APP_ENV=\"$SECTION\""
    fi
    echo "  op run --env-file=$OUTPUT_FILE -- your-command"
}

# Show usage for standalone command
usage() {
    cat << EOF
Usage: op-env-manager template [options]

Generate .env.op template file with op:// secret references from existing
1Password item. The generated file can be safely checked into version control
and used with 'op run' for runtime secret injection.

Options:
    --vault=VAULT       1Password vault name (required)
    --item=NAME         Item name (default: env-secrets)
    --section=SECTION   Environment section (e.g., dev, prod, staging)
    --output=FILE       Output file path (default: .env.op)
    --dry-run           Preview without generating file

Examples:
    # Generate template from existing item
    op-env-manager template --vault="Personal" --item="myapp"

    # Generate template with section (uses \$APP_ENV variable)
    op-env-manager template --vault="Projects" --item="myapp" --section="dev"

    # Custom output filename
    op-env-manager template --vault="Personal" --output=".env.template"

Generated Format:
    # With section:
    API_KEY=op://Personal/myapp/\$APP_ENV/API_KEY

    # Without section:
    API_KEY=op://Personal/myapp/API_KEY

Usage with op run:
    # Set APP_ENV to select section dynamically
    export APP_ENV="dev"
    op run --env-file=.env.op -- docker compose up

EOF
    exit 1
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vault=*)
                VAULT="${1#*=}"
                shift
                ;;
            --vault)
                VAULT="$2"
                shift 2
                ;;
            --item=*)
                ITEM_NAME="${1#*=}"
                shift
                ;;
            --item)
                ITEM_NAME="$2"
                shift 2
                ;;
            --section=*)
                SECTION="${1#*=}"
                shift
                ;;
            --section)
                SECTION="$2"
                shift 2
                ;;
            --output=*)
                OUTPUT_FILE="${1#*=}"
                shift
                ;;
            --output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done
}

# Main function for standalone execution
main() {
    parse_args "$@"
    template_command
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
