#!/usr/bin/env bash
# Inject secrets from 1Password vault into local .env file
# Part of op-env-manager by Matteo Cervelli

set -eo pipefail

# Get script directory
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$LIB_DIR/logger.sh"

# Global variables
OUTPUT_FILE=".env"
VAULT=""
ITEM_NAME=""
DRY_RUN=false
OVERWRITE=false

# Show usage
usage() {
    cat << EOF
Usage: op-env-manager inject [options]

Inject secrets from 1Password vault into local .env file.

Options:
    --vault VAULT       1Password vault name (required)
    --item NAME         Item name prefix (default: env-secrets)
    --output FILE       Output file path (default: .env)
    --overwrite         Overwrite existing file without prompting
    --dry-run           Preview what would be written without actually writing

Examples:
    op-env-manager inject --vault "Personal" --output .env.local
    op-env-manager inject --vault "Work" --item "myapp" --dry-run

Notes:
    - Retrieves all password items with matching item name prefix
    - Creates .env file with KEY=value format
    - File permissions set to 600 (owner read/write only)
    - Prompts before overwriting existing files (unless --overwrite)

EOF
    exit 1
}

# Check if 1Password CLI is installed and authenticated
check_op_cli() {
    if ! command -v op &> /dev/null; then
        log_error "1Password CLI (op) is not installed"
        log_info "See installation guide: docs/1PASSWORD_SETUP.md"
        exit 1
    fi

    if [ "$DRY_RUN" = true ]; then
        log_info "Dry-run mode: skipping 1Password authentication check"
        return 0
    fi

    if ! op account list &> /dev/null; then
        log_error "Not signed in to 1Password CLI"
        log_info "Sign in with: op signin"
        exit 1
    fi

    log_success "1Password CLI authenticated"
}

# Retrieve items from 1Password
get_items_from_1password() {
    local vault="$1"
    local item_prefix="$2"

    log_step "Retrieving items from vault: $vault"

    # Get all items with tag 'op-env-manager' and matching item name
    local items
    items=$(op item list --vault "$vault" --tags "op-env-manager,${item_prefix}" --format json 2>/dev/null)

    if [ -z "$items" ] || [ "$items" = "[]" ]; then
        log_warning "No items found with prefix: $item_prefix"
        log_info "Did you push your .env file first?"
        echo "  op-env-manager push --vault \"$vault\" --item \"$item_prefix\""
        exit 1
    fi

    echo "$items" | jq -r '.[].title'
}

# Retrieve password from item
get_password_from_item() {
    local vault="$1"
    local item_title="$2"

    op item get "$item_title" --vault "$vault" --fields password 2>/dev/null
}

# Inject secrets into .env file
inject_to_env_file() {
    log_header "Injecting Secrets from 1Password"
    echo ""

    if [ -z "$VAULT" ]; then
        log_error "--vault is required"
        usage
    fi

    if [ -z "$ITEM_NAME" ]; then
        ITEM_NAME="env-secrets"
        log_info "Using default item name prefix: $ITEM_NAME"
    fi

    check_op_cli

    # Check if output file exists
    if [ -f "$OUTPUT_FILE" ] && [ "$OVERWRITE" != true ] && [ "$DRY_RUN" != true ]; then
        log_warning "File already exists: $OUTPUT_FILE"
        read -rp "Overwrite? (y/n): " response
        if [ "$response" != "y" ]; then
            log_info "Cancelled"
            exit 0
        fi
    fi

    # Get items from 1Password
    local items
    items=$(get_items_from_1password "$VAULT" "$ITEM_NAME")

    if [ -z "$items" ]; then
        log_error "No items found in vault: $VAULT"
        exit 1
    fi

    local count=0
    local temp_file
    temp_file=$(mktemp)
    trap 'rm -f "$temp_file"' EXIT

    # Header
    echo "# Generated by op-env-manager on $(date -u +"%Y-%m-%d %H:%M:%S UTC")" > "$temp_file"
    echo "# Vault: $VAULT" >> "$temp_file"
    echo "# Item prefix: $ITEM_NAME" >> "$temp_file"
    echo "" >> "$temp_file"

    # Retrieve each item
    log_step "Retrieving secrets..."
    echo ""

    echo "$items" | while IFS= read -r item_title; do
        # Extract key from item title (remove prefix)
        local key="${item_title#${ITEM_NAME}-}"

        if [ "$DRY_RUN" = true ]; then
            log_info "[DRY RUN] Would inject: $key"
            echo "${key}=<secret-from-1password>" >> "$temp_file"
            ((count++))
        else
            local value
            value=$(get_password_from_item "$VAULT" "$item_title")

            if [ -n "$value" ]; then
                echo "${key}=${value}" >> "$temp_file"
                log_success "Retrieved: $key"
                ((count++))
            else
                log_warning "Failed to retrieve: $key"
            fi
        fi
    done

    echo ""

    if [ "$DRY_RUN" = true ]; then
        log_warning "DRY RUN: Preview of what would be written to $OUTPUT_FILE:"
        echo ""
        cat "$temp_file"
        echo ""
        log_info "Remove --dry-run to actually create the file"
    else
        # Write to output file
        cp "$temp_file" "$OUTPUT_FILE"
        chmod 600 "$OUTPUT_FILE"

        log_success "Successfully injected secrets to: $OUTPUT_FILE"
        echo ""
        log_info "File permissions set to 600 (owner read/write only)"
        echo ""
        log_warning "Security reminder:"
        echo "  - Never commit this file to version control"
        echo "  - Add '$OUTPUT_FILE' to your .gitignore"
        echo "  - Rotate secrets regularly in 1Password"
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vault)
                VAULT="$2"
                shift 2
                ;;
            --item)
                ITEM_NAME="$2"
                shift 2
                ;;
            --output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --overwrite)
                OVERWRITE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done
}

# Main function
main() {
    parse_args "$@"
    inject_to_env_file
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
