#!/usr/bin/env bash
# op-env-manager - Bidirectional environment variable sync with 1Password
# by Matteo Cervelli (https://github.com/matteocervelli/op-env-manager)

set -eo pipefail

# Detect installation directory
if [ -L "${BASH_SOURCE[0]}" ]; then
    # If symlinked, follow to actual location
    INSTALL_DIR="$(cd "$(dirname "$(readlink "${BASH_SOURCE[0]}")")" && pwd)"
else
    INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Project root is parent of bin/
PROJECT_ROOT="$(cd "$INSTALL_DIR/.." && pwd)"
LIB_DIR="$PROJECT_ROOT/lib"

# Source utilities
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/error_helpers.sh"
source "$LIB_DIR/retry.sh"
source "$LIB_DIR/progress.sh"

# Version
VERSION="0.3.0"

# Show main usage
usage() {
    cat << EOF
op-env-manager v${VERSION}
Bidirectional environment variable sync with 1Password

USAGE:
    op-env-manager <command> [options]

COMMANDS:
    push        Push local .env file to 1Password vault
    inject      Inject secrets from 1Password to local .env file
    run         Run command with secrets injected from 1Password
    diff        Compare local .env file with 1Password vault
    sync        Bidirectional sync between local .env and 1Password
    convert     Convert .env files with op:// references to op-env-manager format
    template    Generate .env.op template file with op:// references
    init        Interactive setup wizard for 1Password vault
    version     Show version information
    help        Show this help message

EXAMPLES:
    # Push .env to 1Password
    op-env-manager push --vault="Personal" --env-file=.env.production

    # Push with environment section
    op-env-manager push --vault="Projects" --item="myapp" --section="dev" --env-file=.env.dev

    # Inject secrets from 1Password to local .env
    op-env-manager inject --vault="Personal" --output=.env.local

    # Inject with environment section
    op-env-manager inject --vault="Projects" --item="myapp" --section="prod" --output=.env.prod

    # Run command with injected secrets
    op-env-manager run --vault="Personal" --item="myapp" --section="dev" -- docker compose up

    # Run with unmasked secrets (show full values in output)
    op-env-manager run --vault="Personal" --item="myapp" --no-masking -- env | grep API_KEY

    # Compare local .env with 1Password
    op-env-manager diff --vault="Personal" --env-file=.env

    # Sync local .env with 1Password (bidirectional)
    op-env-manager sync --vault="Personal" --env-file=.env

    # Convert legacy .env with op:// references
    op-env-manager convert --vault="Personal" --item="myapp" --env-file=.env.template

    # Generate template file from existing 1Password item
    op-env-manager template --vault="Personal" --item="myapp"

    # Show help for specific command
    op-env-manager push --help

GLOBAL OPTIONS:
    -h, --help      Show help
    -v, --version   Show version
    -q, --quiet     Suppress all non-error output

For more information and documentation:
    https://github.com/matteocervelli/op-env-manager

EOF
    exit 0
}

# Show version
show_version() {
    echo "op-env-manager v${VERSION}"
    echo "by Matteo Cervelli"
    echo ""
    echo "1Password CLI version:"
    if command -v op &> /dev/null; then
        op --version
    else
        echo "  Not installed (required)"
    fi
    exit 0
}

# Run command with injected secrets
run_with_secrets() {
    local vault=""
    local item="env-secrets"
    local section=""
    local env_file=""
    local dry_run=false
    local save_template=false
    local template_output=".env.op"
    local no_masking=false

    # Parse arguments until we hit --
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vault=*)
                vault="${1#*=}"
                shift
                ;;
            --vault)
                vault="$2"
                shift 2
                ;;
            --item=*)
                item="${1#*=}"
                shift
                ;;
            --item)
                item="$2"
                shift 2
                ;;
            --section=*)
                section="${1#*=}"
                shift
                ;;
            --section)
                section="$2"
                shift 2
                ;;
            --env-file=*)
                env_file="${1#*=}"
                shift
                ;;
            --env-file)
                env_file="$2"
                shift 2
                ;;
            --template)
                save_template=true
                shift
                ;;
            --template-output=*)
                save_template=true
                template_output="${1#*=}"
                shift
                ;;
            --template-output)
                save_template=true
                template_output="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --no-masking)
                no_masking=true
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                log_error "Unknown option for run command: $1"
                echo ""
                echo "Usage: op-env-manager run --vault=VAULT [--item=ITEM] [--section=SECTION] [--env-file=FILE] [--template] [--template-output=FILE] [--dry-run] [--no-masking] -- <command>"
                exit 1
                ;;
        esac
    done

    if [ -z "$vault" ]; then
        log_error "--vault is required for run command"
        echo "" >&2
        log_suggestion "Specify a vault name:"
        log_command "op-env-manager run --vault=\"VaultName\" --item=\"item-name\" -- your-command"
        echo "" >&2
        suggest_vault_list
        exit 1
    fi

    if [ "$dry_run" = false ] && [ $# -eq 0 ]; then
        log_error "No command provided after --"
        echo "" >&2
        log_suggestion "Add command after -- separator:"
        log_command "op-env-manager run --vault=\"$vault\" --item=\"$item\" -- your-command"
        echo "" >&2
        log_troubleshoot "Examples:"
        echo "    op-env-manager run --vault=\"Personal\" --item=\"myapp\" -- npm start" >&2
        echo "    op-env-manager run --vault=\"Personal\" --item=\"myapp\" -- docker compose up" >&2
        echo "    op-env-manager run --vault=\"Personal\" --item=\"myapp\" --section=\"dev\" -- ./start.sh" >&2
        echo "" >&2
        exit 1
    fi

    # Check if 1Password CLI is installed and authenticated
    if ! diagnose_op_cli; then
        exit 1
    fi

    log_header "Running Command with 1Password Secrets"
    echo ""
    log_info "Vault: $vault"
    log_info "Item: $item"
    if [ -n "$section" ]; then
        log_info "Section: $section (will use \$APP_ENV variable)"
    fi
    log_info "Command: $*"
    echo ""

    # Source template generation functions
    source "$LIB_DIR/template.sh"

    # Create temporary .env file with secret references
    local temp_env
    temp_env=$(mktemp)
    trap 'rm -f "$temp_env"' EXIT

    # Get item to retrieve field names
    log_step "Building secret references..."
    local item_json
    item_json=$(retry_with_backoff "get item from vault" op item get "$item" --vault "$vault" --format json 2>/dev/null)

    if [ -z "$item_json" ]; then
        log_error "Item not found: $item in vault $vault"

        if [ -n "$section" ]; then
            suggest_item_push "$vault" "$item" ".env"
            echo "" >&2
            log_info "Or check if item exists without section:"
            suggest_item_list "$vault" "$item"
        else
            suggest_item_push "$vault" "$item"
            suggest_item_list "$vault" "$item"
        fi
        exit 1
    fi

    # Collect field names in array
    local field_names=()
    if [ -n "$section" ]; then
        # Get fields from specific section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r ".fields[] | select(.section.label == \"$section\") | .label")
    else
        # Get fields without section
        while IFS= read -r field_name; do
            [ -n "$field_name" ] && field_names+=("$field_name")
        done < <(echo "$item_json" | jq -r '.fields[] | select(.section == null) | .label')
    fi

    # Build secret references using shared function
    for field_name in "${field_names[@]}"; do
        generate_op_reference "$vault" "$item" "$section" "$field_name" >> "$temp_env"
    done

    if [ -n "$section" ]; then
        # Set APP_ENV for this execution
        export APP_ENV="$section"
        log_info "Set APP_ENV=$section"
    fi

    log_success "Secret references created"
    echo ""

    # Save template file if requested
    if [ "$save_template" = true ]; then
        log_step "Saving template file: $template_output"
        generate_template_file "$vault" "$item" "$section" "$template_output" "${field_names[@]}"
        log_success "Template file saved: $template_output"
        echo ""
    fi

    if [ "$dry_run" = true ]; then
        log_warning "DRY RUN: Preview of secret references that would be used:"
        echo ""
        cat "$temp_env"
        echo ""
        if [ -n "$env_file" ]; then
            log_info "Would also load additional env file: $env_file"
        fi
        if [ "$save_template" = true ]; then
            log_info "Would save template file: $template_output"
        fi
        log_info "Would execute command: $*"
        echo ""
        log_warning "Remove --dry-run and add -- <command> to actually run"
    else
        log_step "Executing command with secrets..."
        echo ""

        # Build op run command with optional flags
        local op_run_args=()
        op_run_args+=("--env-file=$temp_env")

        if [ -n "$env_file" ]; then
            op_run_args+=("--env-file=$env_file")
        fi

        if [ "$no_masking" = true ]; then
            op_run_args+=("--no-masking")
        fi

        # Use op run to inject secrets
        op run "${op_run_args[@]}" -- "$@"
    fi
}

# Init command - Interactive setup wizard
init_vault() {
    source "$LIB_DIR/init.sh"
    init_vault_wizard "$@"
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    # Parse global flags first
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)
                export OP_QUIET_MODE=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            -v|--version)
                show_version
                ;;
            *)
                # Not a global flag, treat as command
                break
                ;;
        esac
    done

    local command="$1"
    shift

    case "$command" in
        push)
            source "$LIB_DIR/push.sh"
            main "$@"
            ;;
        inject)
            source "$LIB_DIR/inject.sh"
            main "$@"
            ;;
        run)
            run_with_secrets "$@"
            ;;
        diff)
            source "$LIB_DIR/diff.sh"
            main "$@"
            ;;
        sync)
            source "$LIB_DIR/sync.sh"
            main "$@"
            ;;
        convert)
            source "$LIB_DIR/convert.sh"
            main "$@"
            ;;
        template)
            source "$LIB_DIR/template.sh"
            main "$@"
            ;;
        init)
            init_vault "$@"
            ;;
        version|-v|--version)
            show_version
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            suggest_similar_command "$command"
            usage
            ;;
    esac
}

# Run main
main "$@"
